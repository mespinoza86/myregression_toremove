/* *  V4L2 video capture example * *  This program can be used and distributed without restrictions. */#include <SDL/SDL.h>#include <SDL/SDL_keysym.h>#include <SDL/SDL_opengl.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <assert.h>#include <getopt.h>             /* getopt_long() */#include <fcntl.h>              /* low-level i/o */#include <unistd.h>#include <errno.h>#include <malloc.h>#include <sys/stat.h>#include <sys/types.h>#include <sys/time.h>#include <sys/mman.h>#include <sys/ioctl.h>#include <asm/types.h>          /* for videodev2.h */#include <linux/videodev2.h>#include<FreeImage.h>#include <stdlib.h>#include <stdio.h>#include <string.h>#include <signal.h>#include <unistd.h>#include <sys/syscall.h>#include <sys/stat.h>#include <sys/resource.h>#include "gviewv4l2core.h"#include "save_image_jpeg.h"//The attributes of the screenconst int SCREEN_WIDTH = 300;const int SCREEN_HEIGHT = 300;const int SCREEN_BPP = 32;const int CAM_WIDTH = 1920;const int CAM_HEIGHT = 1080;FREE_IMAGE_FORMAT blah;/*static __THREAD_TYPE capture_thread;__MUTEX_TYPE capture_mutex = __STATIC_MUTEX_INIT;__COND_TYPE capture_cond;*//*pointer to v4l2 device handler*/static v4l2_dev_t *my_vd = NULL;v4l2_frame_buff_t *frame = NULL; //pointer to frame bufferstatic char *           dev_name        = NULL;SDL_Surface* window = NULL;SDL_Event event;GLuint tex[1];time_t begin, end, func_last;u_int8_t done = 0x00;GLfloat diffuse[] = {1.0f, 1.0f, 1.0f, 1.0f}; static int verbose = 1;int first_scale;/* * create a v4l2 device handler * args: *    device - device name * * asserts: *    none * * returns: pointer to v4l2 device handler (or null on error) */v4l2_dev_t *create_v4l2_device_handler(const char *device){	my_vd = v4l2core_init_dev(device);		return my_vd;}int get_image_jpeg(v4l2_frame_buff_t *frame, uint8_t *jpeg ){    //printf("get_image_jpeg begin\n");    		jpeg_encoder_ctx_t *jpeg_ctx = calloc(1, sizeof(jpeg_encoder_ctx_t));	if(jpeg_ctx == NULL)	{		fprintf(stderr, "V4L2_CORE: FATAL memory allocation failure (save_image_jpeg): %s\n", strerror(errno));		exit(-1);	}	/* Initialization of JPEG control structure */	initialization (jpeg_ctx, frame->width, frame->height);	/* Initialization of Quantization Tables  */	initialize_quantization_tables (jpeg_ctx);	int jpeg_size = encode_jpeg(frame->yuv_frame, jpeg, jpeg_ctx, 1);        //printf("get_image_jpeg end\n");    return jpeg_size;}void init_window(){	    SDL_Init(SDL_INIT_VIDEO);	SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER,1);	SDL_GL_SetAttribute(SDL_GL_RED_SIZE, 8);	SDL_GL_SetAttribute(SDL_GL_GREEN_SIZE, 8);	SDL_GL_SetAttribute(SDL_GL_BLUE_SIZE, 8);	window = SDL_SetVideoMode(300,300,0, SDL_HWSURFACE |		       			//SDL_HWPALETTE |					SDL_GL_DOUBLEBUFFER | 		       			SDL_OPENGL);	FreeImage_Initialise(1);	assert(window != NULL);}void Init(void){	glGenTextures(1, tex);	//glShadeModel(GL_SMOOTH);	glClearDepth(1.0f);	glEnable(GL_TEXTURE_2D);	glEnable(GL_DEPTH_TEST);	glEnable(GL_LIGHTING);	glEnable(GL_LIGHT1);	glMatrixMode(GL_PROJECTION);	glOrtho(-1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f);	glMatrixMode(GL_MODELVIEW);	glLoadIdentity();				//LoadTexture(input_file,0); 	time(&begin);	time(&func_last);}void Mem2Texture(FIMEMORY* imageMemory, int tex_num){	int height=0, width=0,pitch=0;	GLubyte* data;		FIBITMAP* map = FreeImage_LoadFromMemory(blah, imageMemory, JPEG_ACCURATE);    map = FreeImage_ConvertTo24Bits(map);             	assert(map != NULL);	width = FreeImage_GetWidth(map);	height = FreeImage_GetHeight(map);            //printf("Image width: %d\n", width);    //printf("Image heigth: %d\n", height);    	pitch = FreeImage_GetPitch(map);	glBindTexture(GL_TEXTURE_2D, tex[tex_num]);	data = malloc(width * height * 3);	FreeImage_ConvertToRawBits(data, map, pitch, 24, 0,0,0,1);	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S,GL_CLAMP);	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,				GL_LINEAR);	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,				GL_LINEAR);	glTexImage2D(GL_TEXTURE_2D, 0, 3,width,	height, 0, GL_BGR, 			GL_UNSIGNED_BYTE, data);	FreeImage_Unload(map);	free(data);            if(first_scale){        if(width>=height){        glScaled(height/300, height/300, 0);    }else{        glScaled(width/300, width/300, 0);    }          first_scale = 0;    }	//printf("Succesfully loaded from memory\n");}void SDL_MyEvents(){                    switch(event.type)            {                case SDL_QUIT:                    done++;                    break;                                    case SDL_KEYDOWN:                                               switch( event.key.keysym.sym ){                        case SDLK_LEFT:                            if(verbose)printf("Left\n");                                                    glTranslatef( 0.01f, 0 , 0 );                            break;                        case SDLK_RIGHT:                            if(verbose)printf("Right\n");                            glTranslatef( -0.01f, 0 , 0 );                                         break;                        case SDLK_UP:                            if(verbose)printf("Up\n");                            glTranslatef( 0, -0.01f , 0 );                            break;                        case SDLK_DOWN:                            if(verbose)printf("Down\n");                            glTranslatef( 0, 0.01f , 0 );                            break;                         case SDLK_q:                            if(verbose)printf("q for clockwise rotation\n");                            glRotatef(1,0.0,0.0,1.0);                            break;                             case SDLK_e:                            if(verbose)printf("e for counterclock rotation\n");                            glRotatef(-1,0.0,0.0,1.0);                            break;                           case SDLK_i:                            if(verbose)printf("i for zoom in\n");                            glScaled(1.01, 1.01, 1.0);                            break;                           case SDLK_o:                            if(verbose)printf("o for zoom out\n");                            glScaled(0.99, 0.99, 1.0);                            break;                                          default:                            break;                    }                                                break;                default:                    break;            }    }void SDL_MyRun(void){	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);	time(&end);    glBindTexture(GL_TEXTURE_2D, tex[0]);    glLightfv(GL_LIGHT1, GL_DIFFUSE, diffuse);    glBegin(GL_QUADS);        glVertex2f(-1.0f, -1.0f);        glTexCoord2f(0.0f, 0.0f);        glVertex2f(-1.0f, 1.0f);        glTexCoord2f(1.0f, 0.0f);        glVertex2f( 1.0f,  1.0f);        glTexCoord2f(1.0f,1.0f);        glVertex2f( 1.0f, -1.0f);        glTexCoord2f(0.0f, 1.0f);    glEnd();	func_last = end;	SDL_GL_SwapBuffers();}void myrender(v4l2_frame_buff_t *frame){                uint8_t *jpeg = calloc((frame->width * frame->height) >> 1, sizeof(uint8_t));    if(jpeg == NULL)    {        fprintf(stderr, "V4L2_CORE: FATAL memory allocation failure (save_image_jpeg): %s\n", strerror(errno));        exit(-1);    }                        int image_size = get_image_jpeg(frame, jpeg );    //printf("image_size: %d\n", image_size);            FIMEMORY *myimage = FreeImage_OpenMemory(jpeg, image_size);              Mem2Texture(myimage,0);             SDL_PollEvent(&event);    SDL_MyEvents();         SDL_MyRun();        //printf("frame is good\n");     free(jpeg);    }static void usage(FILE *fp, int argc, char ** argv){  fprintf (fp,    "Usage: %s [options]\n\n"    "Options:\n"    "-d | --device name   Video device name [/dev/video]\n"    "-h | --help          Print this message\n"    "",		argv[0]);}static const char short_options [] = "d:hmrucg";static const struct option long_options [] = {  { "device",     required_argument,      NULL,           'd' },  { "help",       no_argument,            NULL,           'h' },  { 0, 0, 0, 0 }};int main(int argc, char ** argv){  dev_name = "/dev/video0";  for (;;) {    int index;    int c;        c = getopt_long (argc, argv, short_options, long_options, &index);    if (-1 == c)            break;    switch (c) {    case 0: /* getopt_long() flag */      break;    case 'd':      dev_name = optarg;      break;    case 'h':      usage (stdout, argc, argv);      exit (EXIT_SUCCESS);    default:      usage (stderr, argc, argv);      exit (EXIT_FAILURE);    }  } // for    /*set the v4l2core device (redefines language catalog)*/     v4l2_dev_t *vd = create_v4l2_device_handler(dev_name);    	if(!vd)	{				printf("no video device (%s) found\n", dev_name);				return -1;	}	else{        printf("Video device (%s) found\n", dev_name);   		     }        v4l2core_set_capture_method(vd, IO_MMAP);    	/*set software autofocus sort method*/	v4l2core_soft_autofocus_set_sort(AUTOF_SORT_INSERT);        Init();        v4l2core_prepare_new_format(vd, V4L2_PIX_FMT_MJPEG);    /*prepare resolution*/    v4l2core_prepare_new_resolution(vd, CAM_WIDTH, CAM_HEIGHT);    /*try to set the video stream format on the device*/    int ret = v4l2core_update_current_format(vd);    if(ret != E_OK)    {        fprintf(stderr, "GUCVIEW: could not set the defined stream format\n");        fprintf(stderr, "GUCVIEW: trying first listed stream format\n");        v4l2core_prepare_valid_format(vd);        v4l2core_prepare_valid_resolution(vd);        ret = v4l2core_update_current_format(vd);        if(ret != E_OK)        {            fprintf(stderr, "GUCVIEW: also could not set the first listed stream format\n");            fprintf(stderr, "GUVCVIEW: Video capture failed\n");            //gui_error("Guvcview error", "could not start a video stream in the device", 1);        }    }        if(ret == E_OK)    {                int current_width = v4l2core_get_frame_width(my_vd);		int current_height = v4l2core_get_frame_height(my_vd);                printf("current_width: %d\n",  current_width);         printf("current_height: %d\n", current_height);                 //init_render_sdl1(current_width,current_height,0);                printf("In E_OK\n");        v4l2core_start_stream(my_vd);	    v4l2_frame_buff_t *frame = NULL; //pointer to frame buffer        init_window();        Init();                         char* filename = "./images/reference.jpeg";        /*get the frame from v4l2 core*/                    frame = v4l2core_get_decoded_frame(my_vd);        save_image_jpeg(frame, filename);             v4l2core_release_frame(my_vd, frame);        first_scale = 1;        blah = FreeImage_GetFileType(filename, 0);                                  while(!done)        {                            frame = v4l2core_get_decoded_frame(my_vd);                        if( frame != NULL)            {                                          myrender(frame);                                   v4l2core_release_frame(my_vd, frame);        }         }    printf("Time out done \n"); }                       /*    open_device ();  init_params(argc, argv);    init_device ();    if(init_view()) {	close_device();	return -1;  }		  start_capturing ();  mainloop ();  stop_capturing ();  close_view();  uninit_device ();  close_device ();  */  return 0;}